
# 스프링의 강의 리뷰📽
> LoadMap Part : 스프링 MVC 패턴 1편   
> Section : 04.MVC 프레임워크 만들기  
> CreateDate : 2022.07.16  
> UpdateDate :

### 목차
 - [프론트 컨트롤러 패턴 소개](#Introduction) 
 - [프론트 컨트롤러 도입_v1](#Apply)
 - [View 분리_v2](#ViewSeparation)
 - Model 추가_v3
 - 단순하고 실용적인 컨트롤러_v4
 - 유연한 컨트롤러1_v5
 - 유연한 컨트롤러2
<br></br>
<br></br>

# 프론트 컨트롤러 패턴 소개<a name="Introduction"></a>

<p align="center"><img src="https://user-images.githubusercontent.com/104331549/179345069-34d95401-e87a-43e2-bb27-8f3383858dc1.png" width="80%"></p>
<p align="center"><img src="https://user-images.githubusercontent.com/104331549/179345073-a68ef97f-298e-4a32-af6c-2461dd1bd7ca.png" width="80%"></p>

## FrontController 패턴 특징
 - FrontController도 하나의 서블릿이다.
 - 클라리언트의 요청을 받으면 요청에 맞는 컨트롤러를 찾아서 호출
 - 입구를 하나로 처리함으로, 공통 처리가 가능해진다.
 - 결국, 프론트 컨트롤러를 제외한 나머지 컨트롤러는 서블릿을 사용하지 않아도 됨

### 스프링 웹 MVC와 프론트 컨트롤러
- 스프링 웹 MVC의 핵심도 바로 **FrontController**
- 스프링 웹 MVC의 **DispatcherServlet**이 FrontController 패턴으로 구현되어 있음
   - [DispatcherServlet 알아보기](#DispatcherServlet)


<br></br>
<br></br>

# 프론트 컨트롤러 도입_v1<a name="Apply"></a>
> 프론트 컨트롤러를 단계적으로 도입해보자 

### 1단계 구조
 - Fornt Controller는 URL 매핑 정보에서 컨트롤러를 조회하고, 이에 해당되는 컨트롤러를 찾아 호출해주는 역할 이다.
<p align="center"><img src="https://user-images.githubusercontent.com/104331549/179347005-fa97b43d-69ab-4213-850e-6c587a23c351.png" width="80%"></p>

 - JSP는 사용했던 것을 그대로 사용
 - 프론트컨트롤러는 `ControllerMap`에 출력될 URI를 넣어 놓고, 해당되는 URI를 불러 반환해준다.
   - 만약 없다면, `404(SC_NOT_FOUND)` 상태 코드를 반환한다

### 인터페이스 생성
 - ControllerV1.interface
```java
public interface ControllerV1 {

    void proccess(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException;

}
```
> 기존의 회원등록, 회원저장, 회원 조회 기능은 위에 만들어진 interface를 상속받아 구현한다.

### 프론트컨트롤러_v1
 - 프론트컨트롤러 1버전
 - FrontControllerServletV1.java
```java
@WebServlet(name = "frontControllerServletV1", urlPatterns = "/front-controller/v1/*")
public class FrontControllerServletV1 extends HttpServlet {

    private Map<String, ControllerV1> controllerMap = new HashMap<>();

    public FrontControllerServletV1() {
        controllerMap.put("/front-controller/v1/members/new-form", new MemberFormControllerV1());
        controllerMap.put("/front-controller/v1/members/save", new MemberSaveControllerV1());
        controllerMap.put("/front-controller/v1/members", new MemberListControllerV1());
    }

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        String requestURI = request.getRequestURI();

        ControllerV1 controller = controllerMap.get(requestURI);
        if(controller ==null){
            response.setStatus(HttpServletResponse.SC_NOT_FOUND);
            return;
        }

        controller.proccess(request, response);
    }

}
```

<br></br>
<br></br>

# View 분리_v2<a name="ViewSeparation"></a>
> 모든 컨트롤러에서 뷰로 이동하는 부분에 중복이 있고, 깔끔하지 않다.








<p align="center"><img src="" width="80%"></p>




## 느낀점 😌

## 참고 링크
### DispatcherServlet<a name="DispatcherServlet"></a>
 - spring MVC web 프로젝트를 만들었다면, 이미 외부라이브러리에 가지고 있게 된다.
<img src="https://user-images.githubusercontent.com/104331549/179345999-fbbf7003-e1f3-4317-ae77-d605c383de51.png" width="70%">

 - 디스패처 서블릿은 프론트 컨트롤러로써, 클라이언트로부터 어떠한 요청이 오게 되면 모든 요청을 먼저 받게 된다. 
    - 그리고 요청들을 세부 컨트롤러로 위임한다. 

#### 디스패처서블릿 구현 방법 
 1. 먼저 DispatcherServlet을 생성한다.
 2. 원래의 역할인 공통으로 처리하는 작업을 추가해준다.
 3. 그리고 디스패처서블릿이 관리하는 controller를 일일이 매핑해준다. 
 4. 그리고 요청을 받으면, 컨트롤러에게 위임해주고, 작업이 끝나면 컨트롤러에게 응답을 받아 뷰 오브젝트에 모델을 넘겨주며 최종 결과물을 생성한다.

<p align="center"><img src="https://user-images.githubusercontent.com/104331549/179346775-6f9b9811-3378-416b-91ec-b7e785cb4ce6.png" width="80%"></p>



- [Dispatcher-Servlet](https://mangkyu.tistory.com/18)