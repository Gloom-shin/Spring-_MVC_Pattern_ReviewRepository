
# 스프링의 강의 리뷰📽
> LoadMap Part : 스프링 MVC 패턴 1편   
> Section : 04.MVC 프레임워크 만들기  
> CreateDate : 2022.07.16  
> UpdateDate :

### 목차
 - [프론트 컨트롤러 패턴 소개](#Introduction) 
 - [프론트 컨트롤러 도입_v1](#Apply)
 - [View 분리_v2](#ViewSeparation)
 - [Model 추가_v3](#AddModel)
 - [단순하고 실용적인 컨트롤러_v4](#SimpleAndPractical)
 - 유연한 컨트롤러1_v5
 - 유연한 컨트롤러2

<br></br>

### IntelliJ 단축키
- `ctrl` + `alt` +`M` : 선택된 코드, 외부 메소드로 변환
<br></br>
<br></br>

# 프론트 컨트롤러 패턴 소개<a name="Introduction"></a>

<p align="center"><img src="https://user-images.githubusercontent.com/104331549/179345069-34d95401-e87a-43e2-bb27-8f3383858dc1.png" width="80%"></p>
<p align="center"><img src="https://user-images.githubusercontent.com/104331549/179345073-a68ef97f-298e-4a32-af6c-2461dd1bd7ca.png" width="80%"></p>

## FrontController 패턴 특징
 - FrontController도 하나의 서블릿이다.
 - 클라리언트의 요청을 받으면 요청에 맞는 컨트롤러를 찾아서 호출
 - 입구를 하나로 처리함으로, 공통 처리가 가능해진다.
 - 결국, 프론트 컨트롤러를 제외한 나머지 컨트롤러는 서블릿을 사용하지 않아도 됨

### 스프링 웹 MVC와 프론트 컨트롤러
- 스프링 웹 MVC의 핵심도 바로 **FrontController**
- 스프링 웹 MVC의 **DispatcherServlet**이 FrontController 패턴으로 구현되어 있음
   - [DispatcherServlet 알아보기](#DispatcherServlet)


<br></br>
<br></br>

# 프론트 컨트롤러 도입_v1<a name="Apply"></a>
> 프론트 컨트롤러를 단계적으로 도입해보자 

### 1단계 구조
 - Fornt Controller는 URL 매핑 정보에서 컨트롤러를 조회하고, 이에 해당되는 컨트롤러를 찾아 호출해주는 역할 이다.
<p align="center"><img src="https://user-images.githubusercontent.com/104331549/179347005-fa97b43d-69ab-4213-850e-6c587a23c351.png" width="80%"></p>

 - JSP는 사용했던 것을 그대로 사용
 - 프론트컨트롤러는 `ControllerMap`에 출력될 URI를 넣어 놓고, 해당되는 URI를 불러 반환해준다.
   - 만약 없다면, `404(SC_NOT_FOUND)` 상태 코드를 반환한다

### 인터페이스 생성
 - ControllerV1.interface
```java
public interface ControllerV1 {

    void proccess(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException;

}
```
> 기존의 회원등록, 회원저장, 회원 조회 기능은 위에 만들어진 interface를 상속받아 구현한다.

<br></br>

### 프론트컨트롤러_v1
 - 프론트컨트롤러 1버전
 - FrontControllerServletV1.java
```java
@WebServlet(name = "frontControllerServletV1", urlPatterns = "/front-controller/v1/*")
public class FrontControllerServletV1 extends HttpServlet {

    private Map<String, ControllerV1> controllerMap = new HashMap<>();

    public FrontControllerServletV1() {
        controllerMap.put("/front-controller/v1/members/new-form", new MemberFormControllerV1());
        controllerMap.put("/front-controller/v1/members/save", new MemberSaveControllerV1());
        controllerMap.put("/front-controller/v1/members", new MemberListControllerV1());
    }

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        String requestURI = request.getRequestURI();

        ControllerV1 controller = controllerMap.get(requestURI);
        if(controller ==null){
            response.setStatus(HttpServletResponse.SC_NOT_FOUND);
            return;
        }

        controller.proccess(request, response);
    }

}
```

<br></br>
<br></br>

# View 분리_v2<a name="ViewSeparation"></a>
> **모든 컨트롤러에서 뷰로 이동하는 부분**에 중복이 있고, 깔끔하지 않다.

- 중복되는 부분을 Front Controller로 분리해하여 빼낸다. 

<p align="center"><img src="https://user-images.githubusercontent.com/104331549/179511967-12fdc7cd-0644-4b13-be4b-c6c80cdc13b8.png" width="80%"></p>

<br></br>

### 뷰 렌더링 
 - MyView.java
 - 말 그대로, MyView는 필드값으로 `뷰 경로`를 가지며,
 - render메소드 실행시, **뷰**(`.jsp`)**가 동작**되게 하는 클래스이다.
```java
public class MyView {

    private String viewPath;

    public MyView(String viewPath) {
        this.viewPath = viewPath;
    }

    public void render(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        RequestDispatcher dispatcher =request.getRequestDispatcher(viewPath);
        dispatcher.forward(request, response);
    }

}
```

<br></br>

### 프론트컨트롤러_v2
- FrontControllerServletV2.java
- 요청 값에 해당하는 컨트롤러를 찾고, 
  - 찾은 컨트롤러에서 연결된, ViewPath를 찾고 MyView에 저장하여
  - render()메소드로 뷰 호출(forward)
```java
@WebServlet( name = "frontControllerServletV2", urlPatterns = "/front-controller/v2/*")
public class FrontControllerServletV2 extends HttpServlet {

    private Map<String, ControllerV2> controllerMap = new HashMap<>();

    public FrontControllerServletV2() {
        controllerMap.put("/front-controller/v2/members/new-form", new MemberFormControllerV2());
        controllerMap.put("/front-controller/v2/members/save", new MemberSaveControllerV2());
        controllerMap.put("/front-controller/v2/members", new MemberListControllerV2());
    }

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String requestURI = request.getRequestURI();

        ControllerV2 controller = controllerMap.get(requestURI);

        if (controller == null){
            response.setStatus(HttpServletResponse.SC_NOT_FOUND);
            return;
        }

        MyView view = controller.proccess(request, response); //해당 URI에 맞는 ViewPath 찾기
        view.render(request,response); // view 실행
    }
}
```
 - 인터페이스를 통해 **반환값을 고정**시킴으로써, 다른 사람이 봐도 이해할 수 있는 매우 좋은 설계가 됨.
<br></br>
<br></br>

# Model 추가_v3<a name="AddModel"></a>
## 변경하고자 하는 점
### 서블릿 종속성 제거
 - Myview를 반환해주는 컨트롤러를 보면, 필요없는 정보가 보인다.
```java
public class MemberFormControllerV2 implements ControllerV2 {

        @Override
        public MyView proccess(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            // request랑, response가 굳이 필요할까?
            return new MyView("/WEB-INF/views/new-form.jsp");
        }
}
```
 - 위에 있는 요청 파라미터 정보는  자바의 Map으로 대신 넘기도록하면 지금 구조에서는 컨트롤러가 서블릿 기술을 몰라도 동작할 수 있따. 
 - request 객체를 Model로 사용하는 대신에 별도의 Model 객체를 만들어서 반환
   - 즉, `setAtrribute()`를 사용하지 않음. 

### 뷰 이름 중복제거 
 - 컨트롤러에서 지정하는 뷰 이름에 중복
   - `/WEB-INF/views/new-form.jsp`  -> 논리 이름 : new-form
   - `/WEB-INF/views/save-result.jsp` -> 논리 이름 : save-result
   - `/WEB-INF/views/members.jsp` -> 논리 이름 : members
 - **컨트롤러**가 뷰의 **논리 이름만 반환**
 - 실제 풀네임 위치는 프론트 컨트롤러에서 처리!
    - 뷰의 폴더 위치(풀네임)이 변경되더라도, 프론트 컨트롤러만 고치면 된다.
## V3 

<p align="center"><img src="https://user-images.githubusercontent.com/104331549/179528581-c4bd329a-a708-482a-8bd5-3561d609d5a4.png" width="80%"></p>

- 3번째, 원래는 `MyView`를 반환했었지만, 이번엔 `ModelView`를 반환한다.  
- 4번째, 논리 경로(이름)만 있기에, 실제 경로(풀네임)으로 변환시켜
  - 5번째,`MyView`로 반환한다. 

<br></br>

### 모델 뷰
> 서블릿의 종속성을 제거하기 위해 Model을 직접 만들고, View 이름을 전달하는 객체를 만들자.
 - 즉, 다시한번 언급하지만 `setAtrribute()`를 사용하지 않음
 - ModelView.java
```java
@Getter
@Setter
public class ModelView {
    private String viewName;
    private Map<String, Object> model = new HashMap<>();

    public ModelView(String viewName) {
        this.viewName = viewName;
    }
}
```
 - 이덕에 `Controller`들은 `Map<>`을 인자로 받으며,
   - 반환으로 `viewName`을 초기화하고 `ModelView` 생성해준다.

<br></br>

### 1단계 프론트컨트롤러_v3 
 - 컨트롤러에서 viewModel을 전송해주는 단계까지만 구현
 - 1차 FrontControllerServletV3.java
```java
// 동일한 부분 생략
public class FrontControllerServletV3 extends HttpServlet {

    private Map<String, ControllerV3> controllerMap = new HashMap<>();
    
    // 동일한 부분 생략
    
    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        // 동일한 부분 생략

        //paramMap
        Map<String, String> paramMap = createParamMap(request);

        ModelView modelView = controller.process(paramMap);
        // 에러가 난다.
        view.render(request, response);
    }

    private Map<String, String> createParamMap(HttpServletRequest request) { // Request에서 필요한 파라미터 추출하기
        Map<String, String> paramMap = new HashMap<>();
        request.getParameterNames().asIterator()
                .forEachRemaining(paramName -> paramMap.put(paramName, request.getParameter(paramName)));
        return paramMap;
    }
}
```
 - viewModel은 뷰의 **경로**가 논리이름만 존재하기에, 추가해줘야한다. 
 - 또한, 파라미터 값을 보관하는 `model`값도 view 로 전달해줘야한다. 

<br></br>
### 2단계 프론트컨트롤러_v3
 - 풀 경로로 만드는 방법은 간단하다. 앞뒤에 추가해주면 된다. 
```java
new MyView("/WEB-INF/views/" + modelView.getViewName() + ".jsp");
```
 - 이로써, modelView값이 완성되었고, 이제 MyView에 넣어 넘겨줘야한다.
 - 하지만, model을 인자로 받는 render() 메소드가 존재하지않으므로, 만들어 줘야한다.
```java
ModelView modelView = controller.process(paramMap);
String viewName = modelView.getViewName();
MyView view = viewResolver(viewName); 

view.render(modelView.getModel(),request, response); //존재하지 않음
```

### MyView
 - render()메소드를 오버로딩으로 인자가 다른 render(모델, request, response)만들어 준다.
 - `JSP`는 request.getAttribute() 로 데이터를 조회하기 때문에, 
   - 모델의 데이터를 꺼내서 request.setAttribute() 로 담아둔다
 ```java
public class MyView {
    //생략
    public void render(Map<String, Object> model, HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        modelToRequestAttribute(model, request);
        RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
        dispatcher.forward(request, response);
    }

    private void modelToRequestAttribute(Map<String, Object> model, HttpServletRequest request) {
        model.forEach((key, value) -> request.setAttribute(key, value)); // JSP때문에 데이터를 request.setAttribute()로 담아준다.
    }
}
 ```
- 위 코드들은 더 복잡하고 지저분해 보이지만, 컨트롤러는 매우 간단해졌다.

<br></br>
  <br></br>

# 단순하고 실용적인 컨트롤러_v4<a name="SimpleAndPractical"></a>
 > 구조적으로도 잘 구현했지만, 실제 컨트톨러 인터페이스를 구현하는 개발자 입장에서 보면,   
 > 항상 ModelView 객체를 생성하고 반환해야 하는 부분이 조금은 번거롭다. ex) EJB

 - 즉, 개발자(사용자)한테 불변하면, 더 편리하게 변경하려고 한다. 

## V4

<p align="center"><img src="https://user-images.githubusercontent.com/104331549/179543762-1eb7d32a-fce3-48ac-9e71-4e4dc0b58926.png" width="80%"></p>



<p align="center"><img src="" width="80%"></p>





## 느낀점 😌
 - 공통되고, 지저분해지는 코드는 프론트컨트롤러에서 처리해주고
 - 비즈니스 로직이랑, 뷰 코드는 매우 깔끔하게 해주는듯 하다.


## 참고 링크
### DispatcherServlet<a name="DispatcherServlet"></a>
 - spring MVC web 프로젝트를 만들었다면, 이미 외부라이브러리에 가지고 있게 된다.
<img src="https://user-images.githubusercontent.com/104331549/179345999-fbbf7003-e1f3-4317-ae77-d605c383de51.png" width="70%">

 - 디스패처 서블릿은 프론트 컨트롤러로써, 클라이언트로부터 어떠한 요청이 오게 되면 모든 요청을 먼저 받게 된다. 
    - 그리고 요청들을 세부 컨트롤러로 위임한다. 

#### 디스패처서블릿 구현 방법 
 1. 먼저 DispatcherServlet을 생성한다.
 2. 원래의 역할인 공통으로 처리하는 작업을 추가해준다.
 3. 그리고 디스패처서블릿이 관리하는 controller를 일일이 매핑해준다. 
 4. 그리고 요청을 받으면, 컨트롤러에게 위임해주고, 작업이 끝나면 컨트롤러에게 응답을 받아 뷰 오브젝트에 모델을 넘겨주며 최종 결과물을 생성한다.

<p align="center"><img src="https://user-images.githubusercontent.com/104331549/179346775-6f9b9811-3378-416b-91ec-b7e785cb4ce6.png" width="80%"></p>



- [Dispatcher-Servlet](https://mangkyu.tistory.com/18)