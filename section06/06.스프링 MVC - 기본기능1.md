
# 스프링의 강의 리뷰📽
> LoadMap Part : 스프링 MVC 패턴 1편     
> Section : 06.스프링 MVC - 기본기능    
> CreateDate : 2022.07.23  
> UpdateDate : 2022.07

### 목차
 - [프로젝트 생성](#CreateProject)
 - [로깅 간단히 알아보기](#LoggingTest)
 - [요청 매핑](#RequestMapping)
 - [요청 매핑 - API 예시](#APIexample)
 - HTTP 요청 
   - 기본, 헤더 조회
   - 파라미터 
     - 쿼리 파라미터, HTML Form 
     - @RequestParam
     - @ModelAttribute
<br></br>
### IntelliJ 단축키
<br></br>
<br></br>

# 프로젝트 생성<a name="CreateProject"></a>
- 프로젝트 선택
  - Project: Gradle Project
  - Packaging: **Jar**
  - java : 11
- Dependencies: Spring Web, Thymeleaf, Lombok

### Jar를 선택하는 이유 
 - Jar의 경우
   - 사용하면 항상 내장 서버(톰캣등)을 사용한다. 
   - `webapp` 경로도 사용하지 않는다. 
   - 즉, 내장 서버 사용에 최적화 되어 있는 기능
 - War의 경우 
   - JSP를 사용할 수 있다.
   - 내장 서버도 가능은 하지만, 주로 외부 서버에 배포하는 목적으로 사용

### Welcome 페이지 만들기
 - Jar를 사용한다면,  `/resource/static/index.html` 이 경로에 index.html파일을 만들면 웰컴페이지로 처리해준다.

<br></br>
<br></br>

# 로깅 간단히 알아보기<a name="LoggingTest"></a>
 - 별도의 **로깅 라이브러리**를 사용해서 로그를 출력해보자. 
   - 깊게 들어가면 끝이 없는 영역이다.

### 로깅 라이브러리 
- 스프링 부트 로깅 라이브러리( spring-boot-starter-logging )가 함께 포함된다.
  - SLF4J : 인터페이스 로그 라이브러리
  - Logback : 구현체 로그 라이브러리 
- 로그 라이브러리는 `Logback`, `Log4J`, `Log4J2` 등등 수 많은 라이브러리가 있는데, 그것을 통합해서 인터페이스로 제공하는 것이 바로 `SLF4J` 라이브러리다.
- 실무에서는 스프링부트가 기본으로 제공하는 `Logback`을 대부분 사용한다. 

<br></br>
## 기존 sout과 log 비교하기
### 코드 
```java
@Slf4j
@RestController
public class LongTestController {
//    Slf4j 어노테이션으로 처리가능(lombok라이브러리)
//    private final Logger log = LoggerFactory.getLogger(getClass()); //LongTestController.class
    
    @GetMapping("/log-test")
    public String logTest() {
        String name = "Spring";

        System.out.println("name = " + name);
        log.info(" info log={}", name);

        return "ok";
    }
}
```
### 출력확인 
```shell
name = Spring
2022-07-23 17:44:59.814  INFO 19792 --- [nio-8080-exec-1] h.springmvc.basic.LongTestController     :  info log=Spring
```
 - `System.out.println()`의 경우 ()안에 대한 결과만 찍힌다.
 - 하지만 log.info()의 경우 다양한 정보가 찍힌다.

<p align="center"><img src="https://user-images.githubusercontent.com/104331549/180598373-f9e1fca1-d03c-4baf-9778-296665268c85.png" width="80%"></p>

<br></br>

### 꿀팁
> @RestController 와 @Controller의 차이 
 - 이 둘의 가장 큰 차이는 반환값에 있다.
   - @Controller의 경우 반환값이 응답할 view를 반환한다. 
     - view가 아닌 Data를 반환할 수는 있으나, @ResponseBody 어노테이션을 활용해주어야 한다. 
   - @RestController의 경우 반환값이 응답할 API를 반환한다.
     - 주 용도는 Json 형태로 객체 데이터를 반환하는 것

<br></br>

### 로그 레벨
 - LEVEL: `TRACE` > `DEBUG` > `INFO` > `WARN` > `ERROR`
 - 보통 아래 로그 문구 5가지를 같이 실행시켜도, `INFO` , `WARN` , `ERROR` 만 실행된다.
 - 개발 서버는 debug 출력
   - 운영 서버는 info 출력
```java
log.trace("trace log={}", name);
log.debug("debug log={}", name);
log.info("info log={}", name);
log.warn("warn log={}", name);
log.error("error log={}", name)
```
- 추가적으로 Error 위에, `FATAL` 이라고 하나 더 있다.
  - [참고링크](https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels)
- 개발 실무에서 생각보다 `trace` 로그는 잘 사용하지않는다는데, 알고리즘이 있는 경우 `trace`는 각 단계에 대한 정보 최상의 수준으로 볼수 있다.
- 일반적으로 `trace`로그는 `debug`로그도 포함한다.
  - (`debug`에 모든 `warn` 및 `error`가 포함되는 것처럼).
  - 그래서 너무 출력되는 로그가 방대하다보니 성능을 크게 저하시킨다고 한다.
  - [참고링크](https://softwareengineering.stackexchange.com/questions/279690/why-does-the-trace-level-exist-and-when-should-i-use-it-rather-than-debug)
> 만약 debug나 trace를 띄우고 싶다면, 로그레벨을 설정해줘야한다.

<br></br>

### 로그 레벨 설정
 - `application.properties`
```properties
#전체 로그 레벨 설정(기본 info)
logging.level.root=info
#hello.springmvc 패키지와 그 하위 로그 레벨 설정
logging.level.hello.springmvc=debug 
```
 - 기본값은 `info`로 돼있고, `level`뒤에 `hello.springmvc`를 붙여 해당 패키지와 하위 로그 레벨까지 설정할 수 있다. 
 - 설정값이 `trace`시, 전부 출력, `debug`시 `trace`만 빼고 출력된다.

<br></br>

### 로그 사용시 장점
- 쓰레드 정보, 클래스 이름 같은 부가 정보를 함께 볼 수 있고, 출력 모양을 조정할 수 있다.
- 로그 레벨에 따라 개발 서버에서는 모든 로그를 출력하고, 운영서버에서는 출력하지 않는 등 **로그를 상황에 맞게 조절할 수 있다**
- 시스템 아웃 콘솔에만 출력하는 것이 아니라, 파일이나 네트워크 등, 로그를 별도의 위치에 남길 수 있다.
  - 특히 파일로 남길 때는 일별, 특정 용량에 따라 로그를 분할하는 것도 가능하다.
  - 즉, **내가 원하는 곳(필요한 곳)에 로그를 남겨놓을 수 있게된다.**
- 성능도 일반 `System.out`보다 좋다

<br></br>
<br></br>

# 요청 매핑<a name="RequestMapping"></a>

## @RequestMapping()
### HTTP 메서드
  - 다시한번 더 언급하자면 `@RequestMapping()`을 사용하게 되면, 어떠한 HTTP 메서드를 사용하더라도 무관하게 호출된다. 
  - GET 요청만 매핑하려면 method를 별도로 입력해 줘야한다.`value= "url경로" ,method = RequestMethod.GET`
    - POST 요청만 매핑하려면 `method = RequestMethod.POST` 추가 
    - PATCH, DELETE, PUT 등도 동일하다.
### 다중 매핑 
 - 대부분 어노테이션 속성을 배열로 제공하기 때문에 `@RequestMapping({"/hello-basic", "/hello-go"})` URL 다중 매핑이 가능하다.
### 둘다 허용
   - 원래 URL상의 주소값 `/hello-basic` 과 `/hello-basic/`은 다른 URL로 인식하지만, Spring에서 매핑할때는 둘 다 같은 URL요청으로 인식하여 매핑한다.
     
<br></br>

## PathVariable(경로 변수)

### 사용법
 - 최근 HTTP API는 다음과 같이 리소스 경로에 **식별자**를 넣는 스타일
 - `@RequsetMapping`은 URL경로를 템플릿화(식별자넣기) 할 수 있는데, `@PathVariable`로 조회할 수 있다.
```java
@GetMapping("mapping/{userId}")
public String mappingPath(@PathVariable("userId") String data){
    log.info("mappingPath userId={}", data);
    return "ok";
}
```
 - `@PathVariable` 의 이름과 파라미터 이름이 같으면 생략할 수 있다.
```java
@GetMapping("mapping/{userId}")
public String mappingPath(@PathVariable String userId){ // 변수명을 맞추면, @PathVariable안에 속성 생략 가능
    log.info("mappingPath userId={}", userId); 
    return "ok";
}
```

### 다중사용
 - 식별자를 다중으로 넣을 수도 있다. 
```java
@GetMapping("mapping/users/{userId}/orders/{orderId}")
public String mappingPath(@PathVariable String userId, @PathVariable Long orderId){
    log.info("mappingPath userId={}, orderId={}", userId, orderId);
    return "ok";
}
```

### 특정 파라미터 조건 매핑
- HTTP 요청 URL의 parameter값에 특정 파라미터가 있거나 없는 조건을 추가할 수 있다.
  - 잘 사용하지는 않음
  - 아래는 mode =debug라는 값이 있어야한 HTTP요청이 성공한다.
```java
@GetMapping(value = "/mapping-param", params = "mode=debug")
```

### 특정 헤더 조건 매핑
 - 파라미터 매핑과 비슷하지만, HTTP 헤더를 사용한다
 - Postman으로 테스트

<br></br>
## 미디어 타입 조건 매핑 
### HTTP 요청 Content-Type [consumes]
 - HTTP 요청의 Content-Type헤더를 기반으로 미디어 타입으로 매핑한다.
 - 만약, 맞지 않으면 HTTP 415 상태코드`Unsupported Media Type`을 반환
```java
@PostMapping(value = "/mapping-consume", consumes = MediaType.APPLICATION_JSON_VALUE) // "application/json"
public String mappingConsumes(){
    log.info("mappingConsumes");
    return "ok";
}
```
- json타입 말고도 다른 타입도 가능하다. 
```java
consumes = "text/plain"
consumes = {"text/plain", "application/*"}
consumes = MediaType.TEXT_PLAIN_VALUE
```

### HTTP 요청 Accept [produce]
 - Accept 헤더를 기반으로 미디어 타입으로 매핑한다.
 - 만약 맞지 않으면 HTTP 406 상태코드(Not Acceptable)을 반환한다.

```java
@PostMapping(value = "/mapping-produce", produces = MediaType.TEXT_HTML_VALUE) //"text/html"
public String mappingProduces() {
    log.info("mappingProduces");
    return "ok";
}
```
- text/html 타입말고 다른 타입으로도 클라이언트가 받을 수 있는 지 확인 가능하다.
```java
produces = "text/plain"
produces = {"text/plain", "application/*"}
produces = MediaType.TEXT_PLAIN_VALUE
produces = "text/plain;charset=UTF-8
```

<br></br>
<br></br>

# 요청 매핑 - API 예시<a name="APIexample"></a>



<a name=""></a>
<p align="center"><img src="" width="80%"></p>



## 느낀점 😌

### 참고 링크

